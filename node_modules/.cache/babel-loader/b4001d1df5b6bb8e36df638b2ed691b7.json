{"ast":null,"code":"/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\nconst REQUIRE_MSG = 'Returned error: VM Exception while processing transaction: revert';\nconst ASSERT_MSG = 'Returned error: VM Exception while processing transaction: invalid opcode';\nexport class EVM {\n  constructor(provider) {\n    this.provider = provider;\n  }\n\n  setProvider(provider) {\n    this.provider = provider;\n  }\n  /**\n   * Attempts to reset the EVM to its initial state. Useful for testing suites\n   *\n   * @param provider a valid web3 provider\n   * @returns null\n   */\n\n\n  async resetEVM(resetSnapshotId = '0x1') {\n    const id = await this.snapshot();\n\n    if (id !== resetSnapshotId) {\n      await this.reset(resetSnapshotId);\n    }\n  }\n\n  async reset(id) {\n    if (!id) {\n      throw new Error('id must be set');\n    }\n\n    await this.callJsonrpcMethod('evm_revert', [id]);\n    return this.snapshot();\n  }\n\n  async snapshot() {\n    return this.callJsonrpcMethod('evm_snapshot');\n  }\n\n  async evmRevert(id) {\n    return this.callJsonrpcMethod('evm_revert', [id]);\n  }\n\n  async stopMining() {\n    return this.callJsonrpcMethod('miner_stop');\n  }\n\n  async startMining() {\n    return this.callJsonrpcMethod('miner_start');\n  }\n\n  async mineBlock() {\n    return this.callJsonrpcMethod('evm_mine');\n  }\n\n  async increaseTime(duration) {\n    return this.callJsonrpcMethod('evm_increaseTime', [duration]);\n  }\n\n  async callJsonrpcMethod(method, params) {\n    const args = {\n      method,\n      params,\n      jsonrpc: '2.0',\n      id: new Date().getTime()\n    };\n    const response = await this.send(args);\n    return response.result;\n  }\n\n  async send(args) {\n    return new Promise((resolve, reject) => {\n      const callback = (error, val) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(val);\n        }\n      };\n\n      this.provider.send(args, callback);\n    });\n  } // Helper function\n\n\n  assertCertainError(error, expected_error_msg) {\n    // This complication is so that the actual error will appear in truffle test output\n    const message = error.message;\n    const matchedIndex = message.search(expected_error_msg);\n    let matchedString = message;\n\n    if (matchedIndex === 0) {\n      matchedString = message.substring(matchedIndex, matchedIndex + expected_error_msg.length);\n    }\n\n    expect(matchedString).toEqual(expected_error_msg);\n  } // For solidity function calls that violate require()\n\n\n  async expectThrow(promise, reason) {\n    try {\n      await promise;\n      throw new Error('Did not throw');\n    } catch (e) {\n      this.assertCertainError(e, REQUIRE_MSG);\n\n      if (reason && process.env.COVERAGE !== 'true') {\n        this.assertCertainError(e, `${REQUIRE_MSG} ${reason}`);\n      }\n    }\n  } // For solidity function calls that violate assert()\n\n\n  async expectAssertFailure(promise) {\n    try {\n      await promise;\n      throw new Error('Did not throw');\n    } catch (e) {\n      this.assertCertainError(e, ASSERT_MSG);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/quic.finance/client/src/quic/lib/evm.js"],"names":["REQUIRE_MSG","ASSERT_MSG","EVM","constructor","provider","setProvider","resetEVM","resetSnapshotId","id","snapshot","reset","Error","callJsonrpcMethod","evmRevert","stopMining","startMining","mineBlock","increaseTime","duration","method","params","args","jsonrpc","Date","getTime","response","send","result","Promise","resolve","reject","callback","error","val","assertCertainError","expected_error_msg","message","matchedIndex","search","matchedString","substring","length","expect","toEqual","expectThrow","promise","reason","e","process","env","COVERAGE","expectAssertFailure"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,WAAW,GAChB,mEADD;AAEA,MAAMC,UAAU,GACf,2EADD;AAGA,OAAO,MAAMC,GAAN,CAAU;AAChBC,EAAAA,WAAW,CAACC,QAAD,EAAW;AACrB,SAAKA,QAAL,GAAgBA,QAAhB;AACA;;AAEDC,EAAAA,WAAW,CAACD,QAAD,EAAW;AACrB,SAAKA,QAAL,GAAgBA,QAAhB;AACA;AAED;AACD;AACA;AACA;AACA;AACA;;;AACe,QAARE,QAAQ,CAACC,eAAe,GAAG,KAAnB,EAA0B;AACvC,UAAMC,EAAE,GAAG,MAAM,KAAKC,QAAL,EAAjB;;AAEA,QAAID,EAAE,KAAKD,eAAX,EAA4B;AAC3B,YAAM,KAAKG,KAAL,CAAWH,eAAX,CAAN;AACA;AACD;;AAEU,QAALG,KAAK,CAACF,EAAD,EAAK;AACf,QAAI,CAACA,EAAL,EAAS;AACR,YAAM,IAAIG,KAAJ,CAAU,gBAAV,CAAN;AACA;;AAED,UAAM,KAAKC,iBAAL,CAAuB,YAAvB,EAAqC,CAACJ,EAAD,CAArC,CAAN;AAEA,WAAO,KAAKC,QAAL,EAAP;AACA;;AAEa,QAARA,QAAQ,GAAG;AAChB,WAAO,KAAKG,iBAAL,CAAuB,cAAvB,CAAP;AACA;;AAEc,QAATC,SAAS,CAACL,EAAD,EAAK;AACnB,WAAO,KAAKI,iBAAL,CAAuB,YAAvB,EAAqC,CAACJ,EAAD,CAArC,CAAP;AACA;;AAEe,QAAVM,UAAU,GAAG;AAClB,WAAO,KAAKF,iBAAL,CAAuB,YAAvB,CAAP;AACA;;AAEgB,QAAXG,WAAW,GAAG;AACnB,WAAO,KAAKH,iBAAL,CAAuB,aAAvB,CAAP;AACA;;AAEc,QAATI,SAAS,GAAG;AACjB,WAAO,KAAKJ,iBAAL,CAAuB,UAAvB,CAAP;AACA;;AAEiB,QAAZK,YAAY,CAACC,QAAD,EAAW;AAC5B,WAAO,KAAKN,iBAAL,CAAuB,kBAAvB,EAA2C,CAACM,QAAD,CAA3C,CAAP;AACA;;AAEsB,QAAjBN,iBAAiB,CAACO,MAAD,EAASC,MAAT,EAAiB;AACvC,UAAMC,IAAI,GAAG;AACZF,MAAAA,MADY;AAEZC,MAAAA,MAFY;AAGZE,MAAAA,OAAO,EAAE,KAHG;AAIZd,MAAAA,EAAE,EAAE,IAAIe,IAAJ,GAAWC,OAAX;AAJQ,KAAb;AAOA,UAAMC,QAAQ,GAAG,MAAM,KAAKC,IAAL,CAAUL,IAAV,CAAvB;AAEA,WAAOI,QAAQ,CAACE,MAAhB;AACA;;AAES,QAAJD,IAAI,CAACL,IAAD,EAAO;AAChB,WAAO,IAAIO,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACvC,YAAMC,QAAQ,GAAG,CAACC,KAAD,EAAQC,GAAR,KAAgB;AAChC,YAAID,KAAJ,EAAW;AACVF,UAAAA,MAAM,CAACE,KAAD,CAAN;AACA,SAFD,MAEO;AACNH,UAAAA,OAAO,CAACI,GAAD,CAAP;AACA;AACD,OAND;;AAQA,WAAK7B,QAAL,CAAcsB,IAAd,CAAmBL,IAAnB,EAAyBU,QAAzB;AACA,KAVM,CAAP;AAWA,GAlFe,CAoFhB;;;AACAG,EAAAA,kBAAkB,CAACF,KAAD,EAAQG,kBAAR,EAA4B;AAC7C;AACA,UAAMC,OAAO,GAAGJ,KAAK,CAACI,OAAtB;AACA,UAAMC,YAAY,GAAGD,OAAO,CAACE,MAAR,CAAeH,kBAAf,CAArB;AACA,QAAII,aAAa,GAAGH,OAApB;;AACA,QAAIC,YAAY,KAAK,CAArB,EAAwB;AACvBE,MAAAA,aAAa,GAAGH,OAAO,CAACI,SAAR,CACfH,YADe,EAEfA,YAAY,GAAGF,kBAAkB,CAACM,MAFnB,CAAhB;AAIA;;AACDC,IAAAA,MAAM,CAACH,aAAD,CAAN,CAAsBI,OAAtB,CAA8BR,kBAA9B;AACA,GAjGe,CAmGhB;;;AACiB,QAAXS,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkB;AAClC,QAAI;AACH,YAAMD,OAAN;AACA,YAAM,IAAIlC,KAAJ,CAAU,eAAV,CAAN;AACA,KAHD,CAGE,OAAOoC,CAAP,EAAU;AACX,WAAKb,kBAAL,CAAwBa,CAAxB,EAA2B/C,WAA3B;;AACA,UAAI8C,MAAM,IAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,MAAvC,EAA+C;AAC9C,aAAKhB,kBAAL,CAAwBa,CAAxB,EAA4B,GAAE/C,WAAY,IAAG8C,MAAO,EAApD;AACA;AACD;AACD,GA9Ge,CAgHhB;;;AACyB,QAAnBK,mBAAmB,CAACN,OAAD,EAAU;AAClC,QAAI;AACH,YAAMA,OAAN;AACA,YAAM,IAAIlC,KAAJ,CAAU,eAAV,CAAN;AACA,KAHD,CAGE,OAAOoC,CAAP,EAAU;AACX,WAAKb,kBAAL,CAAwBa,CAAxB,EAA2B9C,UAA3B;AACA;AACD;;AAxHe","sourcesContent":["/*\n\n    Copyright 2019 dYdX Trading Inc.\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n*/\n\nconst REQUIRE_MSG =\n\t'Returned error: VM Exception while processing transaction: revert'\nconst ASSERT_MSG =\n\t'Returned error: VM Exception while processing transaction: invalid opcode'\n\nexport class EVM {\n\tconstructor(provider) {\n\t\tthis.provider = provider\n\t}\n\n\tsetProvider(provider) {\n\t\tthis.provider = provider\n\t}\n\n\t/**\n\t * Attempts to reset the EVM to its initial state. Useful for testing suites\n\t *\n\t * @param provider a valid web3 provider\n\t * @returns null\n\t */\n\tasync resetEVM(resetSnapshotId = '0x1') {\n\t\tconst id = await this.snapshot()\n\n\t\tif (id !== resetSnapshotId) {\n\t\t\tawait this.reset(resetSnapshotId)\n\t\t}\n\t}\n\n\tasync reset(id) {\n\t\tif (!id) {\n\t\t\tthrow new Error('id must be set')\n\t\t}\n\n\t\tawait this.callJsonrpcMethod('evm_revert', [id])\n\n\t\treturn this.snapshot()\n\t}\n\n\tasync snapshot() {\n\t\treturn this.callJsonrpcMethod('evm_snapshot')\n\t}\n\n\tasync evmRevert(id) {\n\t\treturn this.callJsonrpcMethod('evm_revert', [id])\n\t}\n\n\tasync stopMining() {\n\t\treturn this.callJsonrpcMethod('miner_stop')\n\t}\n\n\tasync startMining() {\n\t\treturn this.callJsonrpcMethod('miner_start')\n\t}\n\n\tasync mineBlock() {\n\t\treturn this.callJsonrpcMethod('evm_mine')\n\t}\n\n\tasync increaseTime(duration) {\n\t\treturn this.callJsonrpcMethod('evm_increaseTime', [duration])\n\t}\n\n\tasync callJsonrpcMethod(method, params) {\n\t\tconst args = {\n\t\t\tmethod,\n\t\t\tparams,\n\t\t\tjsonrpc: '2.0',\n\t\t\tid: new Date().getTime(),\n\t\t}\n\n\t\tconst response = await this.send(args)\n\n\t\treturn response.result\n\t}\n\n\tasync send(args) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst callback = (error, val) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(val)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.provider.send(args, callback)\n\t\t})\n\t}\n\n\t// Helper function\n\tassertCertainError(error, expected_error_msg) {\n\t\t// This complication is so that the actual error will appear in truffle test output\n\t\tconst message = error.message\n\t\tconst matchedIndex = message.search(expected_error_msg)\n\t\tlet matchedString = message\n\t\tif (matchedIndex === 0) {\n\t\t\tmatchedString = message.substring(\n\t\t\t\tmatchedIndex,\n\t\t\t\tmatchedIndex + expected_error_msg.length,\n\t\t\t)\n\t\t}\n\t\texpect(matchedString).toEqual(expected_error_msg)\n\t}\n\n\t// For solidity function calls that violate require()\n\tasync expectThrow(promise, reason) {\n\t\ttry {\n\t\t\tawait promise\n\t\t\tthrow new Error('Did not throw')\n\t\t} catch (e) {\n\t\t\tthis.assertCertainError(e, REQUIRE_MSG)\n\t\t\tif (reason && process.env.COVERAGE !== 'true') {\n\t\t\t\tthis.assertCertainError(e, `${REQUIRE_MSG} ${reason}`)\n\t\t\t}\n\t\t}\n\t}\n\n\t// For solidity function calls that violate assert()\n\tasync expectAssertFailure(promise) {\n\t\ttry {\n\t\t\tawait promise\n\t\t\tthrow new Error('Did not throw')\n\t\t} catch (e) {\n\t\t\tthis.assertCertainError(e, ASSERT_MSG)\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}